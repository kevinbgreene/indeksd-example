/* eslint-disable */
/*
 * Autogenerated by indeksd v0.0.15
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
export type Status = {
  id: string;
  displayName: string;
};
export type TodoItem = {
  id: number;
  name: string;
  complete: boolean;
  status?: string;
  timestamp: number;
};
export type TodoItemWithJoins = {
  id: number;
  name: string;
  complete: boolean;
  status?: Status;
  timestamp: number;
};
export type StatusIndexes = 'id';
export type TodosIndexes = 'id' | 'name' | 'status';
export type StatusWhereQueryType<IndexName extends StatusIndexes> =
  IndexName extends 'id' ? string : never;
export type TodosWhereQueryType<IndexName extends TodosIndexes> =
  IndexName extends 'id'
    ? number
    : IndexName extends 'name'
    ? string
    : IndexName extends 'status'
    ? string
    : never;
export type StatusAddArgs = {
  id: string;
  displayName: string;
};
export type TodosAddArgs = {
  name: string;
  complete: boolean;
  status?: string | StatusPutArgs;
  timestamp: number;
};
export type StatusPutArgs =
  | StatusAddArgs
  | {
      id: string;
      displayName: string;
    };
export type TodosPutArgs =
  | TodosAddArgs
  | {
      id: number;
      name: string;
      complete: boolean;
      status?: string | StatusPutArgs;
      timestamp: number;
    };
export type StatusDeleteArgs =
  | string
  | {
      id: string;
    };
export type TodosDeleteArgs =
  | number
  | {
      id: number;
    };
export type StatusGetArgs =
  | string
  | {
      id: string;
    };
export type TodosGetArgs =
  | number
  | {
      id: number;
    }
  | {
      name: string;
    }
  | {
      status: string;
    };
const isStatusIdIndex = (
  arg?: StatusGetArgs,
): arg is {
  id: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'id')
  );
};
const isTodosIdIndex = (
  arg?: TodosGetArgs,
): arg is {
  id: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'id')
  );
};
const isTodosNameIndex = (
  arg?: TodosGetArgs,
): arg is {
  name: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'name')
  );
};
const isTodosStatusIndex = (
  arg?: TodosGetArgs,
): arg is {
  status: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'status')
  );
};
type RangeQuery<ArgType, ReturnType> = {
  isGreaterThan(arg: ArgType): ReturnType;
  isGreaterThanOrEqualTo(arg: ArgType): ReturnType;
  isLessThan(arg: ArgType): ReturnType;
  isLessThanOrEqualTo(arg: ArgType): ReturnType;
  isBetween(arg: { from: ArgType; to: ArgType }): ReturnType;
  isEqualTo(arg: ArgType): ReturnType;
};
export type SubscriptionEvent<ItemType, PrimaryKeyType> =
  | {
      type: 'add' | 'put';
      data: ItemType;
    }
  | {
      type: 'delete';
      data: PrimaryKeyType;
    };
export type StatusClient = {
  subscribe(
    eventName: 'change' | 'add' | 'put' | 'delete',
    callback: (event: SubscriptionEvent<Status, string>) => void,
  ): void;
  add(
    arg: StatusAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Status>;
  put(
    arg: StatusPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Status>;
  delete(
    arg: StatusDeleteArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<void>;
  get(
    arg: StatusGetArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<Status>;
  where<IndexName extends StatusIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
    },
  ): RangeQuery<
    StatusWhereQueryType<IndexName>,
    Promise<ReadonlyArray<Status>>
  >;
  sortBy(
    indexName: StatusIndexes,
    options?: {
      transaction?: IDBTransaction;
      count?: number;
    },
  ): Promise<ReadonlyArray<Status>>;
};
export type TodosClient = {
  subscribe(
    eventName: 'change' | 'add' | 'put' | 'delete',
    callback: (event: SubscriptionEvent<TodoItem, number>) => void,
  ): void;
  add(
    arg: TodosAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<TodoItem>;
  put(
    arg: TodosPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<TodoItem>;
  delete(
    arg: TodosDeleteArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<void>;
  get(
    arg: TodosGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
    },
  ): Promise<TodoItemWithJoins>;
  get(
    arg: TodosGetArgs,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
    },
  ): Promise<TodoItem>;
  get(
    arg: TodosGetArgs,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
    },
  ): Promise<TodoItem | TodoItemWithJoins>;
  where<IndexName extends TodosIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
    },
  ): RangeQuery<
    TodosWhereQueryType<IndexName>,
    Promise<ReadonlyArray<TodoItemWithJoins>>
  >;
  where<IndexName extends TodosIndexes>(
    indexName: IndexName,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
    },
  ): RangeQuery<
    TodosWhereQueryType<IndexName>,
    Promise<ReadonlyArray<TodoItem>>
  >;
  where<IndexName extends TodosIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
    },
  ): RangeQuery<
    TodosWhereQueryType<IndexName>,
    Promise<ReadonlyArray<TodoItem> | ReadonlyArray<TodoItemWithJoins>>
  >;
  sortBy(
    indexName: TodosIndexes,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: true;
      count?: number;
    },
  ): Promise<ReadonlyArray<TodoItemWithJoins>>;
  sortBy(
    indexName: TodosIndexes,
    options: {
      transaction?: IDBTransaction;
      withJoins: false;
      count?: number;
    },
  ): Promise<ReadonlyArray<TodoItem>>;
  sortBy(
    indexName: TodosIndexes,
    options?: {
      transaction?: IDBTransaction;
      withJoins?: boolean;
      count?: number;
    },
  ): Promise<ReadonlyArray<TodoItem> | ReadonlyArray<TodoItemWithJoins>>;
};
export type TodosDatabaseClient = {
  transaction: (
    storeNames: Array<'Status' | 'Todos'>,
    mode?: IDBTransactionMode,
  ) => IDBTransaction;
  status: StatusClient;
  todos: TodosClient;
};
function createDatabaseClient(db: IDBDatabase): TodosDatabaseClient {
  class Observable<ItemType, PrimaryKeyType> {
    #listeners: Map<
      string,
      Map<number, (event: SubscriptionEvent<ItemType, PrimaryKeyType>) => void>
    > = new Map();
    #nextId: number = 0;
    subscribe(
      eventName: 'change' | 'add' | 'put' | 'delete',
      callback: (event: SubscriptionEvent<ItemType, PrimaryKeyType>) => void,
    ): void {
      if (this.#listeners.has(eventName)) {
        this.#listeners.get(eventName)?.set(this.#nextId, callback);
      } else {
        const innerMap: Map<
          number,
          (event: SubscriptionEvent<ItemType, PrimaryKeyType>) => void
        > = new Map();
        innerMap.set(this.#nextId, callback);
        this.#listeners.set(eventName, innerMap);
      }
      this.#nextId += 1;
    }
    _push(eventName: 'delete', data: PrimaryKeyType): void;
    _push(eventName: 'add' | 'put', data: ItemType): void;
    _push(
      eventName: 'add' | 'put' | 'delete',
      data: ItemType | PrimaryKeyType,
    ): void {
      this.#listeners.get('change')?.forEach((callback) => {
        callback({ type: eventName, data } as SubscriptionEvent<
          ItemType,
          PrimaryKeyType
        >);
      });
      this.#listeners.get(eventName)?.forEach((callback) => {
        callback({ type: eventName, data } as SubscriptionEvent<
          ItemType,
          PrimaryKeyType
        >);
      });
    }
  }
  class StatusClientImpl extends Observable<Status, string> {
    static tablesForTransaction: ReadonlyArray<string> = ['Status'];
    add(
      arg: StatusAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Status> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readwrite');
        const store = tx.objectStore('Status');
        const [] = await Promise.all([]);
        const DBAddRequest: IDBRequest = store.add({
          ...arg,
        });
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            const mergedResult: Status = {
              ...arg,
              id: DBAddRequest.result,
            } as Status;
            this._push('add', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: StatusPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Status> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readwrite');
        const store = tx.objectStore('Status');
        const [] = await Promise.all([]);
        const DBPutRequest: IDBRequest = store.put({
          ...arg,
        });
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            const mergedResult: Status = {
              ...arg,
              id: DBPutRequest.result,
            } as Status;
            this._push('put', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    delete(
      arg: StatusDeleteArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readwrite');
        const store = tx.objectStore('Status');
        const idToDelete: string = isStatusIdIndex(arg) ? arg.id : arg;
        const DBDeleteRequest: IDBRequest = store.delete(idToDelete);
        if (DBDeleteRequest != null) {
          DBDeleteRequest.onerror = () => {
            if (DBDeleteRequest != null) {
              reject(DBDeleteRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBDeleteRequest.onsuccess = () => {
            this._push('delete', idToDelete);
            resolve(undefined);
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    get(
      arg: StatusGetArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<Status> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readonly');
        const store = tx.objectStore('Status');
        let DBGetRequest: IDBRequest | null = null;
        if (isStatusIdIndex(arg)) {
          DBGetRequest = store.get(arg.id);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    where<IndexName extends StatusIndexes>(
      indexName: IndexName,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): RangeQuery<
      StatusWhereQueryType<IndexName>,
      Promise<ReadonlyArray<Status>>
    > {
      const tx = options?.transaction ?? db.transaction(['Status'], 'readonly');
      const store = tx.objectStore('Status');
      const executeQuery = (
        target: IDBObjectStore | IDBIndex,
        range: IDBKeyRange,
      ) => {
        return new Promise<ReadonlyArray<Status>>(async (resolve, reject) => {
          const DBGetRequest: IDBRequest = target.getAll(range);
          if (DBGetRequest != null) {
            DBGetRequest.onerror = () => {
              if (DBGetRequest != null) {
                reject(DBGetRequest.error);
              } else {
                reject(
                  new Error(
                    'Unknown error occurred trying to perform operation',
                  ),
                );
              }
            };
            DBGetRequest.onsuccess = () => {
              if (DBGetRequest != null && DBGetRequest.result != null) {
                resolve((DBGetRequest as IDBRequest).result);
              } else {
                reject(new Error('No result found for query'));
              }
            };
          } else {
            reject(new Error('No available index for given query'));
          }
        });
      };
      return {
        isGreaterThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, true));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isGreaterThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, false));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, true));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, false));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isBetween(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(
                store,
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.only(query));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
      };
    }
    sortBy(
      indexName: StatusIndexes,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
        count?: number;
      },
    ): Promise<ReadonlyArray<Status>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Status'], 'readonly');
        const store = tx.objectStore('Status');
        let DBGetRequest: IDBRequest | null = null;
        switch (indexName) {
          case 'id': {
            DBGetRequest = store.getAll(undefined, options?.count);
            break;
          }
          default: {
            return Promise.reject(
              new Error('Trying to run query on unknown index: ' + indexName),
            );
          }
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const statusClient = new StatusClientImpl();
  class TodosClientImpl extends Observable<TodoItem, number> {
    static tablesForTransaction: ReadonlyArray<string> = ['Todos', 'Status'];
    add(
      arg: TodosAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<TodoItem> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...StatusClientImpl.tablesForTransaction,
                ...TodosClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Todos');
        const [statusId] = await Promise.all([
          new Promise<string | null>(async (resolve, reject) => {
            if (arg.status == null) {
              resolve(null);
            } else if (typeof arg.status === 'string') {
              resolve(arg.status);
            } else {
              try {
                const status = await statusClient.put(arg.status, {
                  transaction: tx,
                });
                resolve(status.id);
              } catch (error) {
                reject(error);
              }
            }
          }),
        ]);
        const DBAddRequest: IDBRequest = store.add({
          ...arg,
          status: statusId,
        });
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            const mergedResult: TodoItem = {
              ...arg,
              ...(statusId == null ? {} : { status: statusId }),
              id: DBAddRequest.result,
            } as TodoItem;
            this._push('add', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: TodosPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<TodoItem> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...StatusClientImpl.tablesForTransaction,
                ...TodosClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Todos');
        const [statusId] = await Promise.all([
          new Promise<string | null>(async (resolve, reject) => {
            if (arg.status == null) {
              resolve(null);
            } else if (typeof arg.status === 'string') {
              resolve(arg.status);
            } else {
              try {
                const status = await statusClient.put(arg.status, {
                  transaction: tx,
                });
                resolve(status.id);
              } catch (error) {
                reject(error);
              }
            }
          }),
        ]);
        const DBPutRequest: IDBRequest = store.put({
          ...arg,
          status: statusId,
        });
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            const mergedResult: TodoItem = {
              ...arg,
              ...(statusId == null ? {} : { status: statusId }),
              id: DBPutRequest.result,
            } as TodoItem;
            this._push('put', mergedResult);
            resolve(mergedResult);
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    delete(
      arg: TodosDeleteArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ??
          db.transaction(
            Array.from(
              new Set([
                ...StatusClientImpl.tablesForTransaction,
                ...TodosClientImpl.tablesForTransaction,
              ]),
            ),
            'readwrite',
          );
        const store = tx.objectStore('Todos');
        const idToDelete: number = isTodosIdIndex(arg) ? arg.id : arg;
        const DBDeleteRequest: IDBRequest = store.delete(idToDelete);
        if (DBDeleteRequest != null) {
          DBDeleteRequest.onerror = () => {
            if (DBDeleteRequest != null) {
              reject(DBDeleteRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBDeleteRequest.onsuccess = () => {
            this._push('delete', idToDelete);
            resolve(undefined);
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    get(
      arg: TodosGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
      },
    ): Promise<TodoItemWithJoins>;
    get(
      arg: TodosGetArgs,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): Promise<TodoItem>;
    get(
      arg: TodosGetArgs,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
      },
    ): Promise<TodoItem | TodoItemWithJoins> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? options?.withJoins != false
            ? db.transaction(
                Array.from(
                  new Set([
                    ...StatusClientImpl.tablesForTransaction,
                    ...TodosClientImpl.tablesForTransaction,
                  ]),
                ),
                'readonly',
              )
            : db.transaction(['Todos'], 'readonly');
        const store = tx.objectStore('Todos');
        let DBGetRequest: IDBRequest | null = null;
        if (isTodosIdIndex(arg)) {
          DBGetRequest = store.get(arg.id);
        } else if (isTodosNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.get([arg.name]);
        } else if (isTodosStatusIndex(arg)) {
          const index: IDBIndex = store.index('status');
          DBGetRequest = index.get([arg.status]);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              const todoitem: TodoItem = (DBGetRequest as IDBRequest).result;
              if (options?.withJoins != false) {
                Promise.all([
                  todoitem.status == null
                    ? Promise.resolve<null>(null)
                    : statusClient.get(todoitem.status, { transaction: tx }),
                ]).then(([status]) => {
                  resolve({
                    ...todoitem,
                    ...(status == null ? {} : { status }),
                  } as TodoItemWithJoins);
                });
              } else {
                resolve(todoitem);
              }
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    where<IndexName extends TodosIndexes>(
      indexName: IndexName,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
      },
    ): RangeQuery<
      TodosWhereQueryType<IndexName>,
      Promise<ReadonlyArray<TodoItemWithJoins>>
    >;
    where<IndexName extends TodosIndexes>(
      indexName: IndexName,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): RangeQuery<
      TodosWhereQueryType<IndexName>,
      Promise<ReadonlyArray<TodoItem>>
    >;
    where<IndexName extends TodosIndexes>(
      indexName: IndexName,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
      },
    ): RangeQuery<
      TodosWhereQueryType<IndexName>,
      Promise<ReadonlyArray<TodoItem> | ReadonlyArray<TodoItemWithJoins>>
    > {
      const tx =
        options?.transaction ?? options?.withJoins != false
          ? db.transaction(
              Array.from(
                new Set([
                  ...StatusClientImpl.tablesForTransaction,
                  ...TodosClientImpl.tablesForTransaction,
                ]),
              ),
              'readonly',
            )
          : db.transaction(['Todos'], 'readonly');
      const store = tx.objectStore('Todos');
      const executeQuery = (
        target: IDBObjectStore | IDBIndex,
        range: IDBKeyRange,
      ) => {
        return new Promise<
          ReadonlyArray<TodoItem> | ReadonlyArray<TodoItemWithJoins>
        >(async (resolve, reject) => {
          const DBGetRequest: IDBRequest = target.getAll(range);
          if (DBGetRequest != null) {
            DBGetRequest.onerror = () => {
              if (DBGetRequest != null) {
                reject(DBGetRequest.error);
              } else {
                reject(
                  new Error(
                    'Unknown error occurred trying to perform operation',
                  ),
                );
              }
            };
            DBGetRequest.onsuccess = () => {
              if (DBGetRequest != null && DBGetRequest.result != null) {
                const todoitem: ReadonlyArray<TodoItem> = (
                  DBGetRequest as IDBRequest
                ).result;
                if (options?.withJoins != false) {
                  Promise.all(
                    todoitem.map((result) => {
                      return Promise.all([
                        result.status == null
                          ? Promise.resolve<null>(null)
                          : statusClient.get(result.status, {
                              transaction: tx,
                            }),
                      ]).then(([status]) => {
                        return {
                          ...result,
                          ...(status == null ? {} : { status }),
                        } as TodoItemWithJoins;
                      });
                    }),
                  ).then((result: ReadonlyArray<TodoItemWithJoins>) => {
                    resolve(result);
                  });
                } else {
                  resolve(todoitem);
                }
              } else {
                reject(new Error('No result found for query'));
              }
            };
          } else {
            reject(new Error('No available index for given query'));
          }
        });
      };
      return {
        isGreaterThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isGreaterThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isBetween(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(
                store,
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.only(query));
            }
            case 'name': {
              return executeQuery(store.index('name'), IDBKeyRange.only(query));
            }
            case 'status': {
              return executeQuery(
                store.index('status'),
                IDBKeyRange.only(query),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
      };
    }
    sortBy(
      indexName: TodosIndexes,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: true;
        count?: number;
      },
    ): Promise<ReadonlyArray<TodoItemWithJoins>>;
    sortBy(
      indexName: TodosIndexes,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
        count?: number;
      },
    ): Promise<ReadonlyArray<TodoItem>>;
    sortBy(
      indexName: TodosIndexes,
      options?: {
        transaction?: IDBTransaction;
        withJoins?: boolean;
        count?: number;
      },
    ): Promise<ReadonlyArray<TodoItem> | ReadonlyArray<TodoItemWithJoins>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? options?.withJoins != false
            ? db.transaction(
                Array.from(
                  new Set([
                    ...StatusClientImpl.tablesForTransaction,
                    ...TodosClientImpl.tablesForTransaction,
                  ]),
                ),
                'readonly',
              )
            : db.transaction(['Todos'], 'readonly');
        const store = tx.objectStore('Todos');
        let DBGetRequest: IDBRequest | null = null;
        switch (indexName) {
          case 'id': {
            DBGetRequest = store.getAll(undefined, options?.count);
            break;
          }
          case 'name': {
            const index: IDBIndex = store.index('name');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          case 'status': {
            const index: IDBIndex = store.index('status');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          default: {
            return Promise.reject(
              new Error('Trying to run query on unknown index: ' + indexName),
            );
          }
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              const todoitem: ReadonlyArray<TodoItem> = (
                DBGetRequest as IDBRequest
              ).result;
              if (options?.withJoins != false) {
                Promise.all(
                  todoitem.map((result) => {
                    return Promise.all([
                      result.status == null
                        ? Promise.resolve<null>(null)
                        : statusClient.get(result.status, { transaction: tx }),
                    ]).then(([status]) => {
                      return {
                        ...result,
                        ...(status == null ? {} : { status }),
                      } as TodoItemWithJoins;
                    });
                  }),
                ).then((result: ReadonlyArray<TodoItemWithJoins>) => {
                  resolve(result);
                });
              } else {
                resolve(todoitem);
              }
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const todosClient = new TodosClientImpl();
  return {
    transaction: (
      storeNames: Array<'Status' | 'Todos'>,
      mode?: IDBTransactionMode,
    ): IDBTransaction => {
      return db.transaction(storeNames, mode);
    },
    status: statusClient,
    todos: todosClient,
  };
}
export function init(): Promise<TodosDatabaseClient> {
  return new Promise((resolve, reject) => {
    function createObjectStore(
      db: IDBDatabase,
      storeName: string,
      options: IDBObjectStoreParameters,
    ): IDBObjectStore {
      if (DBOpenRequest.transaction == null) {
        throw new Error(
          'Error opening database. Open request transaction is null.',
        );
      }
      if (db.objectStoreNames.contains(storeName)) {
        return DBOpenRequest.transaction.objectStore(storeName);
      } else {
        return db.createObjectStore(storeName, options);
      }
    }
    function createIndex(
      store: IDBObjectStore,
      indexName: string,
      keyPath: Array<string>,
      options: IDBIndexParameters,
    ): void {
      if (store.indexNames.contains(indexName)) {
        return;
      } else {
        store.createIndex(indexName, keyPath, options);
      }
    }
    function removeUnusedIndexes(
      store: IDBObjectStore,
      indexNames: ReadonlyArray<string>,
    ): void {
      for (const indexName of Array.from(store.indexNames)) {
        if (indexNames.includes(indexName) === false) {
          store.deleteIndex(indexName);
        }
      }
    }
    const DBOpenRequest = globalThis.indexedDB.open('TodosDatabase', 3);
    DBOpenRequest.onerror = () => {
      reject(new Error('Error opening database: TodosDatabase'));
    };
    DBOpenRequest.onsuccess = () => {
      const db = DBOpenRequest.result;
      resolve(createDatabaseClient(db));
    };
    DBOpenRequest.onupgradeneeded = () => {
      const db = DBOpenRequest.result;
      const StatusStore = createObjectStore(db, 'Status', { keyPath: 'id' });
      const TodosStore = createObjectStore(db, 'Todos', {
        keyPath: 'id',
        autoIncrement: true,
      });
      removeUnusedIndexes(StatusStore, ['id']);
      removeUnusedIndexes(TodosStore, ['id', 'name', 'status']);
      createIndex(TodosStore, 'name', ['name'], { unique: false });
      createIndex(TodosStore, 'status', ['status'], { unique: false });
    };
  });
}
