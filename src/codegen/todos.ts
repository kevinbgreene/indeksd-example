/* eslint-disable */
/*
 * Autogenerated by indeksd v0.0.10
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
export type TodoItem = {
  id: number;
  name: string;
  complete: boolean;
  timestamp: number;
};
export type TodosIndexes = 'id' | 'name';
export type TodosWhereQueryType<IndexName extends TodosIndexes> =
  IndexName extends 'id' ? number : IndexName extends 'name' ? string : never;
export type TodosAddArgs = {
  name: string;
  complete: boolean;
  timestamp: number;
};
export type TodosPutArgs =
  | TodosAddArgs
  | {
      id: number;
      name: string;
      complete: boolean;
      timestamp: number;
    };
export type TodosDeleteArgs =
  | number
  | {
      id: number;
    };
export type TodosGetArgs =
  | number
  | {
      id: number;
    }
  | {
      name: string;
    };
const isTodosIdIndex = (
  arg?: TodosGetArgs,
): arg is {
  id: number;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'id')
  );
};
const isTodosNameIndex = (
  arg?: TodosGetArgs,
): arg is {
  name: string;
} => {
  return (
    typeof arg === 'object' &&
    Object.keys(arg).length === 1 &&
    Reflect.has(arg, 'name')
  );
};
type RangeQuery<ArgType, ReturnType> = {
  isGreaterThan(arg: ArgType): ReturnType;
  isGreaterThanOrEqualTo(arg: ArgType): ReturnType;
  isLessThan(arg: ArgType): ReturnType;
  isLessThanOrEqualTo(arg: ArgType): ReturnType;
  isBetween(arg: { from: ArgType; to: ArgType }): ReturnType;
  isEqualTo(arg: ArgType): ReturnType;
};
export type TodosClient = {
  add(
    arg: TodosAddArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<TodoItem>;
  put(
    arg: TodosPutArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<TodoItem>;
  delete(
    arg: TodosDeleteArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<void>;
  get(
    arg: TodosGetArgs,
    options?: {
      transaction?: IDBTransaction;
    },
  ): Promise<TodoItem>;
  where<IndexName extends TodosIndexes>(
    indexName: IndexName,
    options?: {
      transaction?: IDBTransaction;
    },
  ): RangeQuery<
    TodosWhereQueryType<IndexName>,
    Promise<ReadonlyArray<TodoItem>>
  >;
  sortBy(
    indexName: TodosIndexes,
    options?: {
      transaction?: IDBTransaction;
      count?: number;
    },
  ): Promise<ReadonlyArray<TodoItem>>;
};
export type TodosDatabaseClient = {
  transaction: (
    storeNames: Array<'Todos'>,
    mode?: IDBTransactionMode,
  ) => IDBTransaction;
  todos: TodosClient;
};
function createDatabaseClient(db: IDBDatabase): TodosDatabaseClient {
  class TodosClientImpl {
    static tablesForTransaction: ReadonlyArray<string> = ['Todos'];
    add(
      arg: TodosAddArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<TodoItem> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Todos'], 'readwrite');
        const store = tx.objectStore('Todos');
        const [] = await Promise.all([]);
        const DBAddRequest: IDBRequest = store.add({
          ...arg,
        });
        DBAddRequest.onerror = () => {
          if (DBAddRequest != null) {
            reject(DBAddRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBAddRequest.onsuccess = () => {
          if (DBAddRequest != null) {
            resolve({
              ...arg,
              id: DBAddRequest.result,
            });
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    put(
      arg: TodosPutArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<TodoItem> {
      return new Promise(async (resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Todos'], 'readwrite');
        const store = tx.objectStore('Todos');
        const [] = await Promise.all([]);
        const DBPutRequest: IDBRequest = store.put({
          ...arg,
        });
        DBPutRequest.onerror = () => {
          if (DBPutRequest != null) {
            reject(DBPutRequest.error);
          } else {
            reject(
              new Error('Unknown error occurred trying to perform operation'),
            );
          }
        };
        DBPutRequest.onsuccess = () => {
          if (DBPutRequest != null) {
            resolve({
              ...arg,
              id: DBPutRequest.result,
            });
          } else {
            reject(new Error('Operation produced a null result'));
          }
        };
      });
    }
    delete(
      arg: TodosDeleteArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<void> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Todos'], 'readwrite');
        const store = tx.objectStore('Todos');
        let DBDeleteRequest: IDBRequest | null = null;
        if (isTodosIdIndex(arg)) {
          DBDeleteRequest = store.delete(arg.id);
        } else {
          DBDeleteRequest = store.delete(arg);
        }
        if (DBDeleteRequest != null) {
          DBDeleteRequest.onerror = () => {
            if (DBDeleteRequest != null) {
              reject(DBDeleteRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBDeleteRequest.onsuccess = () => {
            resolve(undefined);
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    get(
      arg: TodosGetArgs,
      options?: {
        transaction?: IDBTransaction;
      },
    ): Promise<TodoItem> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Todos'], 'readonly');
        const store = tx.objectStore('Todos');
        let DBGetRequest: IDBRequest | null = null;
        if (isTodosIdIndex(arg)) {
          DBGetRequest = store.get(arg.id);
        } else if (isTodosNameIndex(arg)) {
          const index: IDBIndex = store.index('name');
          DBGetRequest = index.get([arg.name]);
        } else {
          DBGetRequest = store.get(arg);
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
    where<IndexName extends TodosIndexes>(
      indexName: IndexName,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
      },
    ): RangeQuery<
      TodosWhereQueryType<IndexName>,
      Promise<ReadonlyArray<TodoItem>>
    > {
      const tx = options?.transaction ?? db.transaction(['Todos'], 'readonly');
      const store = tx.objectStore('Todos');
      const executeQuery = (
        target: IDBObjectStore | IDBIndex,
        range: IDBKeyRange,
      ) => {
        return new Promise<ReadonlyArray<TodoItem>>(async (resolve, reject) => {
          const DBGetRequest: IDBRequest = target.getAll(range);
          if (DBGetRequest != null) {
            DBGetRequest.onerror = () => {
              if (DBGetRequest != null) {
                reject(DBGetRequest.error);
              } else {
                reject(
                  new Error(
                    'Unknown error occurred trying to perform operation',
                  ),
                );
              }
            };
            DBGetRequest.onsuccess = () => {
              if (DBGetRequest != null && DBGetRequest.result != null) {
                resolve((DBGetRequest as IDBRequest).result);
              } else {
                reject(new Error('No result found for query'));
              }
            };
          } else {
            reject(new Error('No available index for given query'));
          }
        });
      };
      return {
        isGreaterThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isGreaterThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.lowerBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.lowerBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThan(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, true));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, true),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isLessThanOrEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.upperBound(query, false));
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.upperBound(query, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isBetween(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(
                store,
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            case 'name': {
              return executeQuery(
                store.index('name'),
                IDBKeyRange.bound(query.from, query.to, false, false),
              );
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
        isEqualTo(query) {
          switch (indexName) {
            case 'id': {
              return executeQuery(store, IDBKeyRange.only(query));
            }
            case 'name': {
              return executeQuery(store.index('name'), IDBKeyRange.only(query));
            }
            default: {
              return Promise.reject(
                new Error('Trying to run query on unknown index: ' + indexName),
              );
            }
          }
        },
      };
    }
    sortBy(
      indexName: TodosIndexes,
      options: {
        transaction?: IDBTransaction;
        withJoins: false;
        count?: number;
      },
    ): Promise<ReadonlyArray<TodoItem>> {
      return new Promise((resolve, reject) => {
        const tx =
          options?.transaction ?? db.transaction(['Todos'], 'readonly');
        const store = tx.objectStore('Todos');
        let DBGetRequest: IDBRequest | null = null;
        switch (indexName) {
          case 'id': {
            DBGetRequest = store.getAll(undefined, options?.count);
            break;
          }
          case 'name': {
            const index: IDBIndex = store.index('name');
            DBGetRequest = index.getAll(undefined, options?.count);
            break;
          }
          default: {
            return Promise.reject(
              new Error('Trying to run query on unknown index: ' + indexName),
            );
          }
        }
        if (DBGetRequest != null) {
          DBGetRequest.onerror = () => {
            if (DBGetRequest != null) {
              reject(DBGetRequest.error);
            } else {
              reject(
                new Error('Unknown error occurred trying to perform operation'),
              );
            }
          };
          DBGetRequest.onsuccess = () => {
            if (DBGetRequest != null && DBGetRequest.result != null) {
              resolve((DBGetRequest as IDBRequest).result);
            } else {
              reject(new Error('No result found for query'));
            }
          };
        } else {
          reject(new Error('No available index for given query'));
        }
      });
    }
  }
  const todosClient = new TodosClientImpl();
  return {
    transaction: (
      storeNames: Array<'Todos'>,
      mode?: IDBTransactionMode,
    ): IDBTransaction => {
      return db.transaction(storeNames, mode);
    },
    todos: todosClient,
  };
}
export function init(): Promise<TodosDatabaseClient> {
  return new Promise((resolve, reject) => {
    function createObjectStore(
      db: IDBDatabase,
      storeName: string,
      options: IDBObjectStoreParameters,
    ): IDBObjectStore {
      if (DBOpenRequest.transaction == null) {
        throw new Error(
          'Error opening database. Open request transaction is null.',
        );
      }
      if (db.objectStoreNames.contains(storeName)) {
        return DBOpenRequest.transaction.objectStore(storeName);
      } else {
        return db.createObjectStore(storeName, options);
      }
    }
    function createIndex(
      store: IDBObjectStore,
      indexName: string,
      keyPath: Array<string>,
      options: IDBIndexParameters,
    ): void {
      if (store.indexNames.contains(indexName)) {
        return;
      } else {
        store.createIndex(indexName, keyPath, options);
      }
    }
    const DBOpenRequest = globalThis.indexedDB.open('TodosDatabase', 1);
    DBOpenRequest.onerror = () => {
      reject(new Error('Error opening database: TodosDatabase'));
    };
    DBOpenRequest.onsuccess = () => {
      const db = DBOpenRequest.result;
      resolve(createDatabaseClient(db));
    };
    DBOpenRequest.onupgradeneeded = () => {
      const db = DBOpenRequest.result;
      const TodosStore = createObjectStore(db, 'Todos', {
        keyPath: 'id',
        autoIncrement: true,
      });
      createIndex(TodosStore, 'name', ['name'], { unique: false });
    };
  });
}
